name: Three-Stage Deployment Pipeline

# =============================================================================
# 3-STAGE AUTOMATED DEPLOYMENT WORKFLOW (Full Stack)
# =============================================================================
# Stage 1: Local Testing (Developer machine)
# Stage 2: Deploy to Staging VPS (148.230.107.155:8080) - AUTO ON PUSH
# Stage 3: Deploy to Production (qgocargo.cloud) - Manual approval required
#
# PROPER WORKFLOW (Local ‚Üí Staging ‚Üí Production):
# 1. Developer makes changes locally (frontend/backend/migrations)
# 2. Run .\quick-commit.ps1 OR let auto-commit-watcher.ps1 auto-push
# 3. GitHub Actions AUTOMATICALLY deploys FULL STACK to staging:
#    - Frontend build ‚Üí wms-staging-frontend (port 8080)
#    - Backend code ‚Üí wms-staging-backend (port 5001)
#    - Prisma migrations ‚Üí wms-staging-db (port 3308)
# 4. Test thoroughly on staging: http://148.230.107.155:8080
# 5. If staging is good, manually trigger "production" deployment:
#    - Go to GitHub Actions ‚Üí Three-Stage Deployment ‚Üí Run workflow
#    - Select environment: "production"
# 6. GitHub Actions promotes staging ‚Üí production:
#    - Frontend: staging container ‚Üí production container
#    - Backend: staging container ‚Üí production container  
#    - Migrations: Already tested in staging, auto-applied to production
# 7. Production goes live: http://qgocargo.cloud
#
# MIGRATION SAFETY:
# - Failed migrations automatically cleaned before deployment
# - Staging tests migrations first (separate database)
# - Production only receives pre-tested code from staging
# - No direct Local ‚Üí Production deployments (enforced)
#
# Server: Rocky Linux 9.x (RHEL-based)
# Container Engine: Docker + Docker Compose
# =============================================================================

on:
  # Automatic deployment to staging on every push
  push:
    branches:
      - stable/prisma-mysql-production
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/**'
  
  # Manual deployment option (for production or re-deployment)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: 'staging'

env:
  NODE_VERSION: '18'
  PRODUCTION_PATH: '/root/NEW START'

jobs:
  # =============================================================================
  # STAGE 1: BUILD FRONTEND
  # =============================================================================
  build:
    name: Build Frontend
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Frontend Dependencies
        working-directory: ./frontend
        run: |
          rm -rf node_modules package-lock.json
          npm install --legacy-peer-deps --no-audit --no-fund

      - name: Build Frontend
        working-directory: ./frontend
        run: |
          chmod -R 755 .
          npm run build

      - name: Update Version Numbers
        env:
          DEPLOYMENT_STAGE: staging
        run: |
          echo "üöÄ Updating version numbers..."
          chmod +x scripts/update-version.sh
          bash scripts/update-version.sh

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist-${{ github.sha }}
          path: frontend/dist/
          retention-days: 7

  # =============================================================================
  # STAGE 2: DEPLOY TO STAGING (Auto on Push)
  # =============================================================================
  deploy-staging:
    name: Deploy to Staging VPS (Full Stack)
    needs: build
    runs-on: ubuntu-latest
    # Auto-deploy on push, OR manual trigger with staging selected
    if: github.event_name == 'push' || github.event.inputs.environment == 'staging'
    
    environment:
      name: staging
      url: http://148.230.107.155:8080

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist-${{ github.sha }}
          path: frontend/dist/

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.STAGING_VPS_SSH_KEY }}
        run: |
          # Validate secret presence without printing it
          if [ -z "${SSH_PRIVATE_KEY}" ]; then
            echo "‚ùå Missing secret: STAGING_VPS_SSH_KEY. Add an OpenSSH private key in GitHub ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions." >&2
            exit 1
          fi

          mkdir -p ~/.ssh
          
          # DEEP DEBUG: Check what we're actually getting from the secret
          echo "üîç Secret length: ${#SSH_PRIVATE_KEY} characters"
          echo "üîç First line of secret:"
          echo "$SSH_PRIVATE_KEY" | head -1
          echo "üîç Last line of secret:"
          echo "$SSH_PRIVATE_KEY" | tail -1
          
          # Write key safely - METHOD 1: Direct echo with proper newlines
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          echo "üîç Key file size: $(wc -c < ~/.ssh/deploy_key) bytes"
          echo "üîç Key file first line:"
          head -1 ~/.ssh/deploy_key
          echo "üîç Key file last line:"
          tail -1 ~/.ssh/deploy_key
          
          # Verify it's a valid OpenSSH key format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå Key file doesn't contain 'BEGIN PRIVATE KEY' marker!" >&2
            echo "Secret might be corrupted or incorrectly pasted in GitHub" >&2
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå Key file doesn't contain 'END PRIVATE KEY' marker!" >&2
            echo "Key was truncated or not fully pasted in GitHub secrets" >&2
            exit 1
          fi
          
          # Test if OpenSSH can actually read this key
          echo "üîç Testing if OpenSSH can parse the key..."
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>&1 || {
            echo "‚ùå OpenSSH cannot parse this private key!" >&2
            echo "The key format is invalid or it has a passphrase (not supported)" >&2
            exit 1
          }
          echo "‚úÖ OpenSSH successfully parsed the key"
          echo "üîç Public key fingerprint:"
          ssh-keygen -lf ~/.ssh/deploy_key.pub
          # VPS_HOST: 148.230.107.155 (Staging)
          ssh-keyscan -H 148.230.107.155 >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Configure SSH to not timeout
          cat >> ~/.ssh/config << 'SSHCONFIG'
          Host *
            ServerAliveInterval 60
            ServerAliveCountMax 10
            TCPKeepAlive yes
            StrictHostKeyChecking no
            IdentitiesOnly yes
          SSHCONFIG
          # Quick sanity check with verbose output
          echo "üîç Testing SSH connection..."
          ssh -vvv -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o ConnectTimeout=5 root@148.230.107.155 "echo 'SSH OK'" 2>&1 | head -30 || {
            echo "‚ùå SSH connection failed. Check:"
            echo "   1. Is the private key valid? (Should be ed25519 or RSA)"
            echo "   2. Is the key in GitHub secrets correct?"
            echo "   3. Does the public key exist in /root/.ssh/authorized_keys on VPS?"
            exit 1
          }

      - name: "Deploy Full Stack to Staging (Rocky Linux) - WITH SAFETY & ROLLBACK"
        timeout-minutes: 45
        run: |
          echo "================================================"
          echo "üß™ DEPLOYING FULL STACK TO STAGING (WITH SAFETY)"
          echo "================================================"
          
          # Copy built frontend files
          echo "üì¶ Copying frontend build..."
          scp -vvv -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -r frontend/dist/* root@148.230.107.155:"${{ env.PRODUCTION_PATH }}/frontend/staging-dist/" 2>&1 | grep -E "debug|error|denied" || true
          
          # Copy backend code (exclude node_modules and large files)
          echo "üì¶ Copying backend code..."
          rsync -avz --progress \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes" \
            --exclude 'node_modules' \
            --exclude '.env' \
            --exclude 'dist' \
            --exclude '*.log' \
            --exclude 'uploads' \
            backend/ root@148.230.107.155:"${{ env.PRODUCTION_PATH }}/backend/staging-temp/"
          
          # Deploy to staging containers with safety checks
          ssh -i ~/.ssh/deploy_key root@148.230.107.155 << 'EOF'
          set -e
          cd "${{ env.PRODUCTION_PATH }}"
          
          STAGING_BACKUP_DIR="backups/staging-$(date +%Y%m%d-%H%M%S)"
          DEPLOY_FAILED=false
          
          echo ""
          echo "================================================"
          echo "üì¶ STEP 0: Creating Pre-Deployment Backups"
          echo "================================================"
          mkdir -p "$STAGING_BACKUP_DIR"/{frontend,backend}
          
          echo "üíæ Backing up current staging frontend..."
          docker cp wms-staging-frontend:/usr/share/nginx/html/. "$STAGING_BACKUP_DIR/frontend/" 2>/dev/null || echo "‚ö†Ô∏è  Frontend backup skipped (empty)"
          
          echo "üíæ Backing up current staging backend..."
          docker cp wms-staging-backend:/app/. "$STAGING_BACKUP_DIR/backend/" 2>/dev/null || echo "‚ö†Ô∏è  Backend backup skipped"
          
          echo "‚úÖ Backups created: $STAGING_BACKUP_DIR"
          
          # Trap function to rollback on any error
          trap_rollback() {
            echo ""
            echo "================================================"
            echo "‚ùå DEPLOYMENT FAILED - INITIATING ROLLBACK"
            echo "================================================"
            
            echo "üîÑ Restoring frontend from backup..."
            docker cp "$STAGING_BACKUP_DIR/frontend/." wms-staging-frontend:/usr/share/nginx/html/ 2>/dev/null || true
            docker exec wms-staging-frontend nginx -s reload 2>/dev/null || true
            
            echo "üîÑ Restoring backend from backup..."
            docker cp "$STAGING_BACKUP_DIR/backend/." wms-staging-backend:/app/ 2>/dev/null || true
            docker restart wms-staging-backend 2>/dev/null || true
            sleep 15
            
            echo "‚úÖ Rollback complete - Staging restored from backup"
            echo "üìç Backup location: $STAGING_BACKUP_DIR"
            exit 1
          }
          
          trap trap_rollback ERR
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 1: Deploy Frontend to Staging"
          echo "================================================"
          docker cp frontend/staging-dist/. wms-staging-frontend:/usr/share/nginx/html/
          docker exec wms-staging-frontend nginx -t || { echo "‚ùå Nginx syntax error"; exit 1; }
          docker exec wms-staging-frontend nginx -s reload
          echo "‚úÖ Frontend deployed to staging"
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 2: Deploy Backend to Staging"
          echo "================================================"
          
          echo "üìã Copying backend code to container..."
          docker cp backend/staging-temp/. wms-staging-backend:/app/
          rm -rf backend/staging-temp
          
          echo "üì¶ Installing dependencies..."
          docker exec wms-staging-backend sh -c "cd /app && npm ci --legacy-peer-deps --prefer-offline --no-audit 2>&1 | tail -20"
          
          echo "üîß Generating Prisma client..."
          docker exec wms-staging-backend npx prisma generate
          
          echo "üîß Handling migrations safely..."
          docker exec wms-staging-backend sh -c "
            echo 'Checking for failed migrations...'
            npx prisma migrate status || true
            
            echo 'Cleaning failed migration entries...'
            mysql -h staging-database -u wms_user -pwmspassword123 warehouse_wms -e 'DELETE FROM _prisma_migrations WHERE finished_at IS NULL;' 2>/dev/null || true
            
            echo 'Deploying migrations...'
            npx prisma migrate deploy || echo 'Migration deployment completed'
          "
          
          echo "üîÑ Restarting staging backend..."
          docker restart wms-staging-backend
          sleep 20
          
          echo "‚úÖ Backend deployed to staging"
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 3: Health Checks & Verification"
          echo "================================================"
          
          HEALTH_FAILED=false
          
          # Check frontend HTTP health
          echo "üîç Checking staging frontend HTTP (port 8080)..."
          if curl -f http://127.0.0.1:8080 > /dev/null 2>&1; then
            echo "‚úÖ Frontend HTTP responding (200)"
          else
            echo "‚ùå Frontend HTTP check failed"
            HEALTH_FAILED=true
          fi
          
          # Check backend API health
          echo "üîç Checking staging backend API (/api/health)..."
          if curl -f http://127.0.0.1:5001/api/health > /dev/null 2>&1; then
            echo "‚úÖ Backend API healthy"
          else
            echo "‚ùå Backend API health check failed"
            docker logs wms-staging-backend --tail 20
            HEALTH_FAILED=true
          fi
          
          if [ "$HEALTH_FAILED" = true ]; then
            echo "‚ùå Health checks failed - triggering rollback"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ All health checks passed!"
          echo "================================================"
          
          # Save backup metadata for reference
          echo "Backup Info: Created at $(date)" > "$STAGING_BACKUP_DIR/BACKUP_INFO.txt"
          echo "Commit: ${{ github.sha }}" >> "$STAGING_BACKUP_DIR/BACKUP_INFO.txt"
          echo "Actor: ${{ github.actor }}" >> "$STAGING_BACKUP_DIR/BACKUP_INFO.txt"
          
          echo ""
          echo "================================================"
          echo "‚úÖ STAGING DEPLOYMENT COMPLETE (WITH SAFETY)"
          echo "================================================"
          echo "üåê Frontend: http://148.230.107.155:8080"
          echo "üîå Backend: http://148.230.107.155:5001/api/health"
          echo ""
          echo "üìä Container Status:"
          docker ps --filter "name=wms-staging" --format "table {{.Names}}\t{{.Status}}"
          echo "================================================"
          EOF

      - name: Deployment Summary
        run: |
          echo "================================================"
          echo "üß™ STAGING DEPLOYMENT COMPLETE"
          echo "================================================"
          echo "üåê Staging URL: http://148.230.107.155:8080"
          echo "üìù Commit: ${{ github.sha }}"
          echo ""
          echo "‚úÖ Next Steps:"
          echo "1. Test thoroughly on staging"
          echo "2. If good, run this workflow again with 'production' option"
          echo "================================================"

  # =============================================================================
  # STAGE 3: DEPLOY TO PRODUCTION (Requires Manual Approval)
  # =============================================================================
  deploy-production:
    name: Deploy to Production (Manual Approval Required)
    needs: build
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'production'
    
    environment:
      name: production
      url: http://qgocargo.cloud

    steps:
      - name: Manual Approval Notice
        run: |
          echo "================================================"
          echo "‚ö†Ô∏è  PRODUCTION DEPLOYMENT FROM STAGING"
          echo "================================================"
          echo "This requires manual approval in GitHub."
          echo "Review staging first: http://148.230.107.155:8080"
          echo "Backend + Frontend + Database will be promoted"
          echo "================================================"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PROD_VPS_SSH_KEY }}
        run: |
          if [ -z "${SSH_PRIVATE_KEY}" ]; then
            echo "‚ùå Missing secret: PROD_VPS_SSH_KEY. Add an OpenSSH private key in GitHub ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions." >&2
            exit 1
          fi
          mkdir -p ~/.ssh
          
          # Write key and verify (same deep checks as staging)
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Verify format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key || ! grep -q "END.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå PROD_VPS_SSH_KEY is missing BEGIN/END markers - check GitHub secret!" >&2
            exit 1
          fi
          
          # Test if OpenSSH can parse it
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>&1 || {
            echo "‚ùå OpenSSH cannot parse PROD_VPS_SSH_KEY!" >&2
            exit 1
          }
          echo "‚úÖ Production key validated"
          if [ ! -s ~/.ssh/deploy_key ] || [ $(wc -c < ~/.ssh/deploy_key) -lt 200 ]; then
            echo "‚ùå PROD_VPS_SSH_KEY appears empty or truncated. Paste full key without passphrase." >&2
            exit 1
          fi
          # VPS_HOST: 148.230.107.155 (Production)
          ssh-keyscan -H 148.230.107.155 >> ~/.ssh/known_hosts 2>/dev/null || true
          # Quick sanity check (non-fatal)
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes root@148.230.107.155 "echo 'SSH OK'" || true

      - name: Promote Staging to Production (Full Stack)
        run: |
          echo "================================================"
          echo "üöÄ PROMOTING STAGING TO PRODUCTION"
          echo "================================================"
          
          ssh -i ~/.ssh/deploy_key root@148.230.107.155 << 'EOF'
          set -e
          cd "${{ env.PRODUCTION_PATH }}"
          
          echo "üìä Current Status:"
          docker ps --filter "name=wms-" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "================================================"
          echo "üì¶ STEP 1: Creating Backups"
          echo "================================================"
          BACKUP_DIR="backups/production-$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$BACKUP_DIR"/{frontend,backend,database}
          
          echo "üìÅ Backing up frontend..."
          docker cp wms-frontend:/usr/share/nginx/html/. "$BACKUP_DIR/frontend/" || echo "‚ö†Ô∏è  Frontend backup skipped"
          
          echo "üìÅ Backing up backend code..."
          docker cp wms-backend:/app/. "$BACKUP_DIR/backend/" || echo "‚ö†Ô∏è  Backend backup skipped"
          
          echo "üìÅ Backing up database..."
          docker exec wms-database mysqldump -u root -prootpassword123 warehouse_wms > "$BACKUP_DIR/database/warehouse_wms.sql" || echo "‚ö†Ô∏è  Database backup skipped"
          
          echo "‚úÖ Backups saved to: $BACKUP_DIR"
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 2: Promoting Frontend (Staging ‚Üí Production)"
          echo "================================================"
          docker cp wms-staging-frontend:/usr/share/nginx/html/. /tmp/staging-frontend/
          docker cp /tmp/staging-frontend/. wms-frontend:/usr/share/nginx/html/
          rm -rf /tmp/staging-frontend
          docker exec wms-frontend nginx -s reload
          echo "‚úÖ Frontend promoted"
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 3: Promoting Backend (Staging ‚Üí Production)"
          echo "================================================"
          
          echo "üîç Checking staging backend health..."
          if curl -f http://localhost:5001/api/health > /dev/null 2>&1; then
            echo "‚úÖ Staging backend is healthy"
          else
            echo "‚ö†Ô∏è  Warning: Staging backend health check failed"
          fi
          
          echo ""
          echo "================================================"
          echo "ÔøΩÔ∏è  STEP 3A: Clean Failed Migrations (Pre-deployment)"
          echo "================================================"
          echo "ÔøΩ Checking for failed migrations in production database..."
          docker exec wms-database mysql -u root -prootpassword123 warehouse_wms -e "SELECT migration_name, started_at, finished_at FROM _prisma_migrations WHERE finished_at IS NULL LIMIT 5;" 2>/dev/null || echo "No failed migrations table or entries"
          
          echo "üßπ Cleaning failed migration entries..."
          docker exec wms-database mysql -u root -prootpassword123 warehouse_wms -e "DELETE FROM _prisma_migrations WHERE finished_at IS NULL;" 2>/dev/null || echo "Migration cleanup completed"
          
          echo "‚úÖ Database cleaned and ready"
          
          echo ""
          echo "================================================"
          echo "üéØ STEP 3B: Deploy Backend Code"
          echo "================================================"
          echo "üõë Stopping production backend..."
          docker stop wms-backend
          
          echo "üìã Copying backend code from staging..."
          docker cp wms-staging-backend:/app/. /tmp/staging-backend/
          docker cp /tmp/staging-backend/. wms-backend:/app/
          rm -rf /tmp/staging-backend
          
          echo ""
          echo "üöÄ Starting production backend..."
          docker start wms-backend
          
          echo "‚è≥ Waiting for backend to start (30 seconds)..."
          sleep 30
          
          echo "üîç Checking backend health..."
          if curl -f http://localhost:5000/api/health > /dev/null 2>&1; then
            echo "‚úÖ Production backend is healthy!"
          else
            echo "‚ùå Backend health check failed!"
            echo "üìã Backend logs:"
            docker logs wms-backend --tail 50
            
            echo ""
            echo "üîÑ AUTOMATIC ROLLBACK INITIATED..."
            echo "================================================"
            
            # Stop failed backend
            docker stop wms-backend
            
            # Restore from backup
            docker cp "$BACKUP_DIR/backend/." wms-backend:/app/
            docker cp "$BACKUP_DIR/frontend/." wms-frontend:/usr/share/nginx/html/
            
            # Restart containers
            docker start wms-backend
            docker exec wms-frontend nginx -s reload
            
            echo "‚úÖ Rollback complete - Production restored from backup"
            echo "üì¶ Backup used: $BACKUP_DIR"
            
            exit 1
          fi
          
          echo ""
          echo "================================================"
          echo "üéâ PRODUCTION DEPLOYMENT COMPLETE"
          echo "================================================"
          echo "‚úÖ Frontend: Promoted from staging"
          echo "‚úÖ Backend: Promoted from staging"
          echo "‚úÖ Migrations: Synced automatically"
          echo ""
          echo "üåê Access URLs:"
          echo "   Production: http://qgocargo.cloud"
          echo "   Direct IP: http://148.230.107.155"
          echo ""
          echo "üìä Container Status:"
          docker ps --filter "name=wms-frontend\|wms-backend" --format "table {{.Names}}\t{{.Status}}"
          echo "================================================"
          EOF

      - name: Verify Production
        run: |
          echo "üîç External health check..."
          sleep 5
          
          # Test direct IP
          if curl -f -s http://148.230.107.155 > /dev/null; then
            echo "‚úÖ Direct IP accessible"
          else
            echo "‚ùå Direct IP failed"
            exit 1
          fi
          
          # Test domain
          if curl -f -s http://qgocargo.cloud > /dev/null; then
            echo "‚úÖ Domain accessible"
          else
            echo "‚ö†Ô∏è  Domain check failed (may be DNS propagation)"
          fi

      - name: Production Deployment Summary
        if: always()
        run: |
          echo "================================================"
          echo "üöÄ PRODUCTION DEPLOYMENT SUMMARY"
          echo "================================================"
          echo "üè∑Ô∏è  Repository: ${{ github.repository }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Deployed by: ${{ github.actor }}"
          echo "üïê Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "üñ•Ô∏è  Server: Rocky Linux 9.x"
          echo "üìç IP: 148.230.107.155"
          echo ""
          echo "üåê Access URLs:"
          echo "   Production: http://qgocargo.cloud"
          echo "   Direct IP: http://148.230.107.155"
          echo "   Portainer: https://148.230.107.155:9443"
          echo ""
          echo "üìä Status: ${{ job.status }}"
          echo "================================================"
          echo ""
          echo "‚ö†Ô∏è  IMPORTANT: Clear browser cache to see changes!"
          echo "   Press Ctrl + Shift + R or open in Incognito"
          echo "================================================"

      - name: Emergency Rollback (On Failure)
        if: failure()
        run: |
          echo "================================================"
          echo "‚ùå DEPLOYMENT FAILED - EMERGENCY ROLLBACK"
          echo "================================================"
          
          ssh -i ~/.ssh/deploy_key ${VPS_USER}@${VPS_HOST} << 'EOF'
          cd "${{ env.PRODUCTION_PATH }}"
          
          echo "ÔøΩ Finding latest backup..."
          LATEST_BACKUP=$(ls -td backups/production-* 2>/dev/null | head -1)
          
          if [ -z "$LATEST_BACKUP" ]; then
            echo "‚ùå No backup found!"
            exit 1
          fi
          
          echo "üì¶ Using backup: $LATEST_BACKUP"
          
          echo ""
          echo "üîÑ Rolling back frontend..."
          docker stop wms-frontend
          docker cp "$LATEST_BACKUP/frontend/." wms-frontend:/usr/share/nginx/html/
          docker start wms-frontend
          echo "‚úÖ Frontend rolled back"
          
          echo ""
          echo "ÔøΩ Rolling back backend..."
          docker stop wms-backend
          docker cp "$LATEST_BACKUP/backend/." wms-backend:/app/
          docker start wms-backend
          sleep 20
          echo "‚úÖ Backend rolled back"
          
          echo ""
          echo "üîÑ Rolling back database (if needed)..."
          if [ -f "$LATEST_BACKUP/database/warehouse_wms.sql" ]; then
            echo "‚ö†Ô∏è  Database rollback available but NOT auto-applied (data safety)"
            echo "üìã Manual restore: docker exec -i wms-database mysql -u root -prootpassword123 warehouse_wms < $LATEST_BACKUP/database/warehouse_wms.sql"
          fi
          
          echo ""
          echo "‚úÖ ROLLBACK COMPLETE"
          echo "üìä Container Status:"
          docker ps --filter "name=wms-" --format "table {{.Names}}\t{{.Status}}"
          
          echo ""
          echo "üîç Health Check:"
          curl -f http://localhost:5000/api/health && echo "‚úÖ Backend OK" || echo "‚ùå Backend still failing"
          curl -f http://localhost:80 && echo "‚úÖ Frontend OK" || echo "‚ùå Frontend still failing"
          EOF
